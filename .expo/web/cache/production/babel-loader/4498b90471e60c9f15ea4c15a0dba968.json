{"ast":null,"code":"'use strict';module.exports=Transform;var _require$codes=require(\"../errors\").codes,ERR_METHOD_NOT_IMPLEMENTED=_require$codes.ERR_METHOD_NOT_IMPLEMENTED,ERR_MULTIPLE_CALLBACK=_require$codes.ERR_MULTIPLE_CALLBACK,ERR_TRANSFORM_ALREADY_TRANSFORMING=_require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,ERR_TRANSFORM_WITH_LENGTH_0=_require$codes.ERR_TRANSFORM_WITH_LENGTH_0;var Duplex=require(\"./_stream_duplex\");require('inherits')(Transform,Duplex);function afterTransform(er,data){var ts=this._transformState;ts.transforming=false;var cb=ts.writecb;if(cb===null){return this.emit('error',new ERR_MULTIPLE_CALLBACK());}ts.writechunk=null;ts.writecb=null;if(data!=null)this.push(data);cb(er);var rs=this._readableState;rs.reading=false;if(rs.needReadable||rs.length<rs.highWaterMark){this._read(rs.highWaterMark);}}function Transform(options){if(!(this instanceof Transform))return new Transform(options);Duplex.call(this,options);this._transformState={afterTransform:afterTransform.bind(this),needTransform:false,transforming:false,writecb:null,writechunk:null,writeencoding:null};this._readableState.needReadable=true;this._readableState.sync=false;if(options){if(typeof options.transform==='function')this._transform=options.transform;if(typeof options.flush==='function')this._flush=options.flush;}this.on('prefinish',prefinish);}function prefinish(){var _this=this;if(typeof this._flush==='function'&&!this._readableState.destroyed){this._flush(function(er,data){done(_this,er,data);});}else{done(this,null,null);}}Transform.prototype.push=function(chunk,encoding){this._transformState.needTransform=false;return Duplex.prototype.push.call(this,chunk,encoding);};Transform.prototype._transform=function(chunk,encoding,cb){cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));};Transform.prototype._write=function(chunk,encoding,cb){var ts=this._transformState;ts.writecb=cb;ts.writechunk=chunk;ts.writeencoding=encoding;if(!ts.transforming){var rs=this._readableState;if(ts.needTransform||rs.needReadable||rs.length<rs.highWaterMark)this._read(rs.highWaterMark);}};Transform.prototype._read=function(n){var ts=this._transformState;if(ts.writechunk!==null&&!ts.transforming){ts.transforming=true;this._transform(ts.writechunk,ts.writeencoding,ts.afterTransform);}else{ts.needTransform=true;}};Transform.prototype._destroy=function(err,cb){Duplex.prototype._destroy.call(this,err,function(err2){cb(err2);});};function done(stream,er,data){if(er)return stream.emit('error',er);if(data!=null)stream.push(data);if(stream._writableState.length)throw new ERR_TRANSFORM_WITH_LENGTH_0();if(stream._transformState.transforming)throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();return stream.push(null);}","map":{"version":3,"sources":["/Users/naohirofujie/.anyenv/envs/nodenv/versions/14.5.0/lib/node_modules/expo-cli/node_modules/browserify-sign/node_modules/readable-stream/lib/_stream_transform.js"],"names":["module","exports","Transform","_require$codes","require","codes","ERR_METHOD_NOT_IMPLEMENTED","ERR_MULTIPLE_CALLBACK","ERR_TRANSFORM_ALREADY_TRANSFORMING","ERR_TRANSFORM_WITH_LENGTH_0","Duplex","afterTransform","er","data","ts","_transformState","transforming","cb","writecb","emit","writechunk","push","rs","_readableState","reading","needReadable","length","highWaterMark","_read","options","call","bind","needTransform","writeencoding","sync","transform","_transform","flush","_flush","on","prefinish","_this","destroyed","done","prototype","chunk","encoding","_write","n","_destroy","err","err2","stream","_writableState"],"mappings":"AA6DA,aAEAA,MAAM,CAACC,OAAP,CAAiBC,SAAjB,CAEA,GAAIC,CAAAA,cAAc,CAAGC,OAAO,aAAP,CAAqBC,KAA1C,CACIC,0BAA0B,CAAGH,cAAc,CAACG,0BADhD,CAEIC,qBAAqB,CAAGJ,cAAc,CAACI,qBAF3C,CAGIC,kCAAkC,CAAGL,cAAc,CAACK,kCAHxD,CAIIC,2BAA2B,CAAGN,cAAc,CAACM,2BAJjD,CAMA,GAAIC,CAAAA,MAAM,CAAGN,OAAO,oBAApB,CAEAA,OAAO,CAAC,UAAD,CAAP,CAAoBF,SAApB,CAA+BQ,MAA/B,EAEA,QAASC,CAAAA,cAAT,CAAwBC,EAAxB,CAA4BC,IAA5B,CAAkC,CAChC,GAAIC,CAAAA,EAAE,CAAG,KAAKC,eAAd,CACAD,EAAE,CAACE,YAAH,CAAkB,KAAlB,CACA,GAAIC,CAAAA,EAAE,CAAGH,EAAE,CAACI,OAAZ,CAEA,GAAID,EAAE,GAAK,IAAX,CAAiB,CACf,MAAO,MAAKE,IAAL,CAAU,OAAV,CAAmB,GAAIZ,CAAAA,qBAAJ,EAAnB,CAAP,CACD,CAEDO,EAAE,CAACM,UAAH,CAAgB,IAAhB,CACAN,EAAE,CAACI,OAAH,CAAa,IAAb,CACA,GAAIL,IAAI,EAAI,IAAZ,CACE,KAAKQ,IAAL,CAAUR,IAAV,EACFI,EAAE,CAACL,EAAD,CAAF,CACA,GAAIU,CAAAA,EAAE,CAAG,KAAKC,cAAd,CACAD,EAAE,CAACE,OAAH,CAAa,KAAb,CAEA,GAAIF,EAAE,CAACG,YAAH,EAAmBH,EAAE,CAACI,MAAH,CAAYJ,EAAE,CAACK,aAAtC,CAAqD,CACnD,KAAKC,KAAL,CAAWN,EAAE,CAACK,aAAd,EACD,CACF,CAED,QAASzB,CAAAA,SAAT,CAAmB2B,OAAnB,CAA4B,CAC1B,GAAI,EAAE,eAAgB3B,CAAAA,SAAlB,CAAJ,CAAkC,MAAO,IAAIA,CAAAA,SAAJ,CAAc2B,OAAd,CAAP,CAClCnB,MAAM,CAACoB,IAAP,CAAY,IAAZ,CAAkBD,OAAlB,EACA,KAAKd,eAAL,CAAuB,CACrBJ,cAAc,CAAEA,cAAc,CAACoB,IAAf,CAAoB,IAApB,CADK,CAErBC,aAAa,CAAE,KAFM,CAGrBhB,YAAY,CAAE,KAHO,CAIrBE,OAAO,CAAE,IAJY,CAKrBE,UAAU,CAAE,IALS,CAMrBa,aAAa,CAAE,IANM,CAAvB,CASA,KAAKV,cAAL,CAAoBE,YAApB,CAAmC,IAAnC,CAIA,KAAKF,cAAL,CAAoBW,IAApB,CAA2B,KAA3B,CAEA,GAAIL,OAAJ,CAAa,CACX,GAAI,MAAOA,CAAAA,OAAO,CAACM,SAAf,GAA6B,UAAjC,CAA6C,KAAKC,UAAL,CAAkBP,OAAO,CAACM,SAA1B,CAC7C,GAAI,MAAON,CAAAA,OAAO,CAACQ,KAAf,GAAyB,UAA7B,CAAyC,KAAKC,MAAL,CAAcT,OAAO,CAACQ,KAAtB,CAC1C,CAGD,KAAKE,EAAL,CAAQ,WAAR,CAAqBC,SAArB,EACD,CAED,QAASA,CAAAA,SAAT,EAAqB,CACnB,GAAIC,CAAAA,KAAK,CAAG,IAAZ,CAEA,GAAI,MAAO,MAAKH,MAAZ,GAAuB,UAAvB,EAAqC,CAAC,KAAKf,cAAL,CAAoBmB,SAA9D,CAAyE,CACvE,KAAKJ,MAAL,CAAY,SAAU1B,EAAV,CAAcC,IAAd,CAAoB,CAC9B8B,IAAI,CAACF,KAAD,CAAQ7B,EAAR,CAAYC,IAAZ,CAAJ,CACD,CAFD,EAGD,CAJD,IAIO,CACL8B,IAAI,CAAC,IAAD,CAAO,IAAP,CAAa,IAAb,CAAJ,CACD,CACF,CAEDzC,SAAS,CAAC0C,SAAV,CAAoBvB,IAApB,CAA2B,SAAUwB,KAAV,CAAiBC,QAAjB,CAA2B,CACpD,KAAK/B,eAAL,CAAqBiB,aAArB,CAAqC,KAArC,CACA,MAAOtB,CAAAA,MAAM,CAACkC,SAAP,CAAiBvB,IAAjB,CAAsBS,IAAtB,CAA2B,IAA3B,CAAiCe,KAAjC,CAAwCC,QAAxC,CAAP,CACD,CAHD,CAeA5C,SAAS,CAAC0C,SAAV,CAAoBR,UAApB,CAAiC,SAAUS,KAAV,CAAiBC,QAAjB,CAA2B7B,EAA3B,CAA+B,CAC9DA,EAAE,CAAC,GAAIX,CAAAA,0BAAJ,CAA+B,cAA/B,CAAD,CAAF,CACD,CAFD,CAIAJ,SAAS,CAAC0C,SAAV,CAAoBG,MAApB,CAA6B,SAAUF,KAAV,CAAiBC,QAAjB,CAA2B7B,EAA3B,CAA+B,CAC1D,GAAIH,CAAAA,EAAE,CAAG,KAAKC,eAAd,CACAD,EAAE,CAACI,OAAH,CAAaD,EAAb,CACAH,EAAE,CAACM,UAAH,CAAgByB,KAAhB,CACA/B,EAAE,CAACmB,aAAH,CAAmBa,QAAnB,CAEA,GAAI,CAAChC,EAAE,CAACE,YAAR,CAAsB,CACpB,GAAIM,CAAAA,EAAE,CAAG,KAAKC,cAAd,CACA,GAAIT,EAAE,CAACkB,aAAH,EAAoBV,EAAE,CAACG,YAAvB,EAAuCH,EAAE,CAACI,MAAH,CAAYJ,EAAE,CAACK,aAA1D,CAAyE,KAAKC,KAAL,CAAWN,EAAE,CAACK,aAAd,EAC1E,CACF,CAVD,CAeAzB,SAAS,CAAC0C,SAAV,CAAoBhB,KAApB,CAA4B,SAAUoB,CAAV,CAAa,CACvC,GAAIlC,CAAAA,EAAE,CAAG,KAAKC,eAAd,CAEA,GAAID,EAAE,CAACM,UAAH,GAAkB,IAAlB,EAA0B,CAACN,EAAE,CAACE,YAAlC,CAAgD,CAC9CF,EAAE,CAACE,YAAH,CAAkB,IAAlB,CAEA,KAAKoB,UAAL,CAAgBtB,EAAE,CAACM,UAAnB,CAA+BN,EAAE,CAACmB,aAAlC,CAAiDnB,EAAE,CAACH,cAApD,EACD,CAJD,IAIO,CAGLG,EAAE,CAACkB,aAAH,CAAmB,IAAnB,CACD,CACF,CAZD,CAcA9B,SAAS,CAAC0C,SAAV,CAAoBK,QAApB,CAA+B,SAAUC,GAAV,CAAejC,EAAf,CAAmB,CAChDP,MAAM,CAACkC,SAAP,CAAiBK,QAAjB,CAA0BnB,IAA1B,CAA+B,IAA/B,CAAqCoB,GAArC,CAA0C,SAAUC,IAAV,CAAgB,CACxDlC,EAAE,CAACkC,IAAD,CAAF,CACD,CAFD,EAGD,CAJD,CAMA,QAASR,CAAAA,IAAT,CAAcS,MAAd,CAAsBxC,EAAtB,CAA0BC,IAA1B,CAAgC,CAC9B,GAAID,EAAJ,CAAQ,MAAOwC,CAAAA,MAAM,CAACjC,IAAP,CAAY,OAAZ,CAAqBP,EAArB,CAAP,CACR,GAAIC,IAAI,EAAI,IAAZ,CACEuC,MAAM,CAAC/B,IAAP,CAAYR,IAAZ,EAIF,GAAIuC,MAAM,CAACC,cAAP,CAAsB3B,MAA1B,CAAkC,KAAM,IAAIjB,CAAAA,2BAAJ,EAAN,CAClC,GAAI2C,MAAM,CAACrC,eAAP,CAAuBC,YAA3B,CAAyC,KAAM,IAAIR,CAAAA,kCAAJ,EAAN,CACzC,MAAO4C,CAAAA,MAAM,CAAC/B,IAAP,CAAY,IAAZ,CAAP,CACD","sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n'use strict';\n\nmodule.exports = Transform;\n\nvar _require$codes = require('../errors').codes,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\n\nvar Duplex = require('./_stream_duplex');\n\nrequire('inherits')(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  }; // start out asking for a readable event once data is transformed.\n\n  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  } // When the writable side finishes, then flush out anything remaining.\n\n\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n}; // This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\n\n\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n}; // Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\n\n\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}"]},"metadata":{},"sourceType":"script"}