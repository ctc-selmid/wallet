{"ast":null,"code":"import _toConsumableArray from\"@babel/runtime/helpers/toConsumableArray\";import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _extends from\"@babel/runtime/helpers/extends\";import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}import*as queryString from'query-string';import checkLegacyPathConfig from\"./checkLegacyPathConfig\";var getActiveRoute=function getActiveRoute(state){var route=typeof state.index==='number'?state.routes[state.index]:state.routes[state.routes.length-1];if(route.state){return getActiveRoute(route.state);}return route;};export default function getPathFromState(state,options){if(state==null){throw Error(\"Got 'undefined' for the navigation state. You must pass a valid state object.\");}var _checkLegacyPathConfi=checkLegacyPathConfig(options),_checkLegacyPathConfi2=_slicedToArray(_checkLegacyPathConfi,2),legacy=_checkLegacyPathConfi2[0],compatOptions=_checkLegacyPathConfi2[1];var configs=compatOptions?createNormalizedConfigs(legacy,compatOptions.screens):{};var path='/';var current=state;var allParams={};var _loop=function _loop(){var index=typeof current.index==='number'?current.index:0;var route=current.routes[index];var pattern=void 0;var focusedParams=void 0;var focusedRoute=getActiveRoute(state);var currentOptions=configs;var nestedRouteNames=[];var hasNext=true;while(route.name in currentOptions&&hasNext){pattern=currentOptions[route.name].pattern;nestedRouteNames.push(route.name);if(route.params){(function(){var stringify=(_currentOptions$route=currentOptions[route.name])===null||_currentOptions$route===void 0?void 0:_currentOptions$route.stringify;var currentParams=fromEntries(Object.entries(route.params).map(function(_ref){var _ref2=_slicedToArray(_ref,2),key=_ref2[0],value=_ref2[1];return[key,(stringify===null||stringify===void 0?void 0:stringify[key])?stringify[key](value):String(value)];}));if(pattern){_extends(allParams,currentParams);}if(focusedRoute===route){focusedParams=_objectSpread({},currentParams);(_pattern=pattern)===null||_pattern===void 0?void 0:_pattern.split('/').filter(function(p){return p.startsWith(':');}).forEach(function(p){var name=getParamName(p);if(focusedParams){delete focusedParams[name];}});}})();}if(!currentOptions[route.name].screens||route.state===undefined){hasNext=false;}else{index=typeof route.state.index==='number'?route.state.index:route.state.routes.length-1;var nextRoute=route.state.routes[index];var nestedConfig=currentOptions[route.name].screens;if(nestedConfig&&nextRoute.name in nestedConfig){route=nextRoute;currentOptions=nestedConfig;}else{hasNext=false;}}}if(pattern===undefined){pattern=nestedRouteNames.join('/');}if(currentOptions[route.name]!==undefined){path+=pattern.split('/').map(function(p){var name=getParamName(p);if(p==='*'){if(legacy){throw new Error(\"Please update your config to the new format to use wildcard pattern ('*'). https://reactnavigation.org/docs/configuring-links/#updating-config\");}return route.name;}if(p.startsWith(':')){var value=allParams[name];if(value===undefined&&p.endsWith('?')){return'';}return encodeURIComponent(value);}return encodeURIComponent(p);}).join('/');}else{path+=encodeURIComponent(route.name);}if(!focusedParams){focusedParams=focusedRoute.params;}if(route.state){path+='/';}else if(focusedParams){for(var param in focusedParams){if(focusedParams[param]==='undefined'){delete focusedParams[param];}}var query=queryString.stringify(focusedParams);if(query){path+=\"?\".concat(query);}}current=route.state;};while(current){var _currentOptions$route;var _pattern;_loop();}path=path.replace(/\\/+/g,'/');path=path.length>1?path.replace(/\\/$/,''):path;return path;}var fromEntries=function fromEntries(entries){return entries.reduce(function(acc,_ref3){var _ref4=_slicedToArray(_ref3,2),k=_ref4[0],v=_ref4[1];if(acc.hasOwnProperty(k)){throw new Error(\"A value for key '\".concat(k,\"' already exists in the object.\"));}acc[k]=v;return acc;},{});};var getParamName=function getParamName(pattern){return pattern.replace(/^:/,'').replace(/\\?$/,'');};var joinPaths=function joinPaths(){var _ref5;for(var _len=arguments.length,paths=new Array(_len),_key=0;_key<_len;_key++){paths[_key]=arguments[_key];}return(_ref5=[]).concat.apply(_ref5,_toConsumableArray(paths.map(function(p){return p.split('/');}))).filter(Boolean).join('/');};var createConfigItem=function createConfigItem(legacy,config,parentPattern){var _pattern2;if(typeof config==='string'){var _pattern3=parentPattern?joinPaths(parentPattern,config):config;return{pattern:_pattern3};}var pattern;if(legacy){pattern=config.exact!==true&&parentPattern&&config.path?joinPaths(parentPattern,config.path):config.path;}else{if(config.exact&&config.path===undefined){throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");}pattern=config.exact!==true?joinPaths(parentPattern||'',config.path||''):config.path||'';}var screens=config.screens?createNormalizedConfigs(legacy,config.screens,pattern):undefined;return{pattern:(_pattern2=pattern)===null||_pattern2===void 0?void 0:_pattern2.split('/').filter(Boolean).join('/'),stringify:config.stringify,screens:screens};};var createNormalizedConfigs=function createNormalizedConfigs(legacy,options,pattern){return fromEntries(Object.entries(options).map(function(_ref6){var _ref7=_slicedToArray(_ref6,2),name=_ref7[0],c=_ref7[1];var result=createConfigItem(legacy,c,pattern);return[name,result];}));};","map":{"version":3,"sources":["getPathFromState.tsx"],"names":["getActiveRoute","state","route","Error","checkLegacyPathConfig","configs","compatOptions","createNormalizedConfigs","path","current","allParams","index","pattern","focusedParams","focusedRoute","currentOptions","nestedRouteNames","hasNext","stringify","currentParams","fromEntries","Object","String","p","name","getParamName","nextRoute","nestedConfig","value","encodeURIComponent","query","queryString","entries","acc","joinPaths","paths","createConfigItem","parentPattern","config","screens","result"],"mappings":"8hCAAA,MAAO,GAAP,CAAA,WAAA,KAAA,cAAA,CAMA,MAAA,CAAA,qBAAA,+BAeA,GAAMA,CAAAA,cAAc,CAAIC,QAAlBD,CAAAA,cAAkBC,CAAAA,KAAD,CAAqD,CAC1E,GAAMC,CAAAA,KAAK,CACT,MAAOD,CAAAA,KAAK,CAAZ,KAAA,GAAA,QAAA,CACIA,KAAK,CAALA,MAAAA,CAAaA,KAAK,CADtB,KACIA,CADJ,CAEIA,KAAK,CAALA,MAAAA,CAAaA,KAAK,CAALA,MAAAA,CAAAA,MAAAA,CAHnB,CAGMA,CAHN,CAKA,GAAIC,KAAK,CAAT,KAAA,CAAiB,CACf,MAAOF,CAAAA,cAAc,CAACE,KAAK,CAA3B,KAAqB,CAArB,CACD,CAED,MAAA,CAAA,KAAA,CAVF,CAAA,CA0CA,cAAe,SAAA,CAAA,gBAAA,CAAA,KAAA,CAAA,OAAA,CAGL,CACR,GAAID,KAAK,EAAT,IAAA,CAAmB,CACjB,KAAME,CAAAA,KAAK,CAAX,+EAAW,CAAX,CAGD,CALO,0BAOwBC,qBAAqB,CAP7C,OAO6C,CAP7C,gEAOF,MAPE,2BAOF,aAPE,2BAUR,GAAMC,CAAAA,OAAmC,CAAGC,aAAa,CACrDC,uBAAuB,CAAA,MAAA,CAASD,aAAa,CADQ,OAC9B,CAD8B,CAAzD,EAAA,CAIA,GAAIE,CAAAA,IAAI,CAAR,GAAA,CACA,GAAIC,CAAAA,OAA0B,CAA9B,KAAA,CAEA,GAAMC,CAAAA,SAA8B,CAApC,EAAA,CAjBQ,2BAoBN,GAAIC,CAAAA,KAAK,CAAG,MAAOF,CAAAA,OAAO,CAAd,KAAA,GAAA,QAAA,CAAoCA,OAAO,CAA3C,KAAA,CAAZ,CAAA,CACA,GAAIP,CAAAA,KAAK,CAAGO,OAAO,CAAPA,MAAAA,CAAZ,KAAYA,CAAZ,CAIA,GAAIG,CAAAA,OAAJ,OAAA,CAEA,GAAIC,CAAAA,aAAJ,OAAA,CACA,GAAIC,CAAAA,YAAY,CAAGd,cAAc,CAAjC,KAAiC,CAAjC,CACA,GAAIe,CAAAA,cAAc,CAVJ,OAUd,CAGA,GAAIC,CAAAA,gBAAgB,CAApB,EAAA,CAEA,GAAIC,CAAAA,OAAO,CAAX,IAAA,CAEA,MAAOf,KAAK,CAALA,IAAAA,GAAAA,CAAAA,cAAAA,EAAP,OAAA,CAAgD,CAC9CU,OAAO,CAAGG,cAAc,CAACb,KAAK,CAApBa,IAAc,CAAdA,CAAVH,OAAAA,CAEAI,gBAAgB,CAAhBA,IAAAA,CAAsBd,KAAK,CAA3Bc,IAAAA,EAEA,GAAId,KAAK,CAAT,MAAA,CAAkB,aAChB,GAAMgB,CAAAA,SAAS,CAAA,CAAA,qBAAA,CAAGH,cAAc,CAACb,KAAK,CAAvB,IAAiB,CAAjB,IAAA,IAAA,EAAA,qBAAA,GAAA,IAAA,EAAA,CAAA,IAAA,EAAA,CAAGa,qBAAAA,CAAlB,SAAA,CAEA,GAAMI,CAAAA,aAAa,CAAGC,WAAW,CAC/BC,MAAM,CAANA,OAAAA,CAAenB,KAAK,CAApBmB,MAAAA,EAAAA,GAAAA,CAAiC,gDAAC,GAAD,UAAA,KAAA,gBAAkB,CAAA,GAAA,CAEjD,CAAA,SAAS,GAAT,IAAA,EAAA,SAAS,GAAA,IAAT,EAAA,CAAA,IAAA,EAAA,CAAA,SAAS,CAAT,GAAS,CAAT,EAAmBH,SAAS,CAATA,GAAS,CAATA,CAAnB,KAAmBA,CAAnB,CAA2CI,MAAM,CAHrD,KAGqD,CAFA,CAAlB,EAAjCD,CAD+B,CAAjC,CAOA,GAAA,OAAA,CAAa,CACXA,SAAAA,SAAAA,CAAAA,aAAAA,EACD,CAED,GAAIP,YAAY,GAAhB,KAAA,CAA4B,CAG1BD,aAAa,kBAAQM,aAAR,CAAbN,CAEA,CAAA,QAAA,CAAA,OAAA,IAAA,IAAA,EAAA,QAAA,GAAA,IAAA,EAAA,CAAA,IAAA,EAAA,CAAA,QAAA,CAAA,KAAA,CAAA,GAAA,EAAA,MAAA,CAEWU,SAAAA,CAAD,QAAOA,CAAAA,CAAC,CAADA,UAAAA,CAFjB,GAEiBA,CAAP,EAFV,EAAA,OAAA,CAIYA,SAAAA,CAAD,CAAO,CACd,GAAMC,CAAAA,IAAI,CAAGC,YAAY,CADX,CACW,CAAzB,CAGA,GAAA,aAAA,CAAmB,CAEjB,MAAOZ,CAAAA,aAAa,CAApB,IAAoB,CAApB,CACD,CAXL,CAAA,CAAA,CAaD,CAhCe,KAL4B,CAyC9C,GAAI,CAACE,cAAc,CAACb,KAAK,CAApBa,IAAc,CAAdA,CAAD,OAAA,EAAuCb,KAAK,CAALA,KAAAA,GAA3C,SAAA,CAAsE,CACpEe,OAAO,CAAPA,KAAAA,CADF,CAAA,IAEO,CACLN,KAAK,CACH,MAAOT,CAAAA,KAAK,CAALA,KAAAA,CAAP,KAAA,GAAA,QAAA,CACIA,KAAK,CAALA,KAAAA,CADJ,KAAA,CAEIA,KAAK,CAALA,KAAAA,CAAAA,MAAAA,CAAAA,MAAAA,CAHNS,CAAAA,CAKA,GAAMe,CAAAA,SAAS,CAAGxB,KAAK,CAALA,KAAAA,CAAAA,MAAAA,CAAlB,KAAkBA,CAAlB,CACA,GAAMyB,CAAAA,YAAY,CAAGZ,cAAc,CAACb,KAAK,CAApBa,IAAc,CAAdA,CAPhB,OAOL,CAGA,GAAIY,YAAY,EAAID,SAAS,CAATA,IAAAA,GAApB,CAAA,YAAA,CAAoD,CAClDxB,KAAK,CAALA,SAAAA,CACAa,cAAc,CAAdA,YAAAA,CAFF,CAAA,IAGO,CAELE,OAAO,CAAPA,KAAAA,CACD,CACF,CACF,CAED,GAAIL,OAAO,GAAX,SAAA,CAA2B,CACzBA,OAAO,CAAGI,gBAAgB,CAAhBA,IAAAA,CAAVJ,GAAUI,CAAVJ,CACD,CAED,GAAIG,cAAc,CAACb,KAAK,CAApBa,IAAc,CAAdA,GAAJ,SAAA,CAA8C,CAC5CP,IAAI,EAAI,OAAO,CAAP,KAAA,CAAA,GAAA,EAAA,GAAA,CAEAe,SAAAA,CAAD,CAAO,CACV,GAAMC,CAAAA,IAAI,CAAGC,YAAY,CADf,CACe,CAAzB,CAKA,GAAIF,CAAC,GAAL,GAAA,CAAe,CACb,GAAA,MAAA,CAAY,CACV,KAAM,IAAA,CAAA,KAAA,CAAN,gJAAM,CAAN,CAGD,CAED,MAAOrB,CAAAA,KAAK,CAAZ,IAAA,CAbQ,CAiBV,GAAIqB,CAAC,CAADA,UAAAA,CAAJ,GAAIA,CAAJ,CAAuB,CACrB,GAAMK,CAAAA,KAAK,CAAGlB,SAAS,CAAvB,IAAuB,CAAvB,CAEA,GAAIkB,KAAK,GAALA,SAAAA,EAAuBL,CAAC,CAADA,QAAAA,CAA3B,GAA2BA,CAA3B,CAA4C,CAE1C,MAAA,EAAA,CACD,CAED,MAAOM,CAAAA,kBAAkB,CAAzB,KAAyB,CAAzB,CACD,CAED,MAAOA,CAAAA,kBAAkB,CAAzB,CAAyB,CAAzB,CA9BI,CAAA,EAAA,IAAA,CAARrB,GAAQ,CAARA,CADF,CAAA,IAkCO,CACLA,IAAI,EAAIqB,kBAAkB,CAAC3B,KAAK,CAAhCM,IAA0B,CAA1BA,CACD,CAED,GAAI,CAAJ,aAAA,CAAoB,CAClBK,aAAa,CAAGC,YAAY,CAA5BD,MAAAA,CACD,CAED,GAAIX,KAAK,CAAT,KAAA,CAAiB,CACfM,IAAI,EAAJA,GAAAA,CADF,CAAA,IAEO,IAAA,aAAA,CAAmB,CACxB,IAAK,GAAL,CAAA,KAAA,GAAA,CAAA,aAAA,CAAiC,CAC/B,GAAIK,aAAa,CAAbA,KAAa,CAAbA,GAAJ,WAAA,CAA0C,CAExC,MAAOA,CAAAA,aAAa,CAApB,KAAoB,CAApB,CACD,CACF,CAED,GAAMiB,CAAAA,KAAK,CAAGC,WAAW,CAAXA,SAAAA,CAAd,aAAcA,CAAd,CAEA,GAAA,KAAA,CAAW,CACTvB,IAAI,EAAA,IAAA,MAAA,CAAJA,KAAI,CAAJA,CACD,CACF,CAEDC,OAAO,CAAGP,KAAK,CAAfO,KAAAA,CAlKM,EAmBR,MAAA,OAAA,CAAgB,IAsBM,CAAA,qBAtBN,IAoCkB,CAAA,QApClB,SAnBR,CAsKRD,IAAI,CAAGA,IAAI,CAAJA,OAAAA,CAAAA,MAAAA,CAAPA,GAAOA,CAAPA,CACAA,IAAI,CAAGA,IAAI,CAAJA,MAAAA,CAAAA,CAAAA,CAAkBA,IAAI,CAAJA,OAAAA,CAAAA,KAAAA,CAAlBA,EAAkBA,CAAlBA,CAAPA,IAAAA,CAEA,MAAA,CAAA,IAAA,CAGF,CACA,GAAMY,CAAAA,WAAW,CAAyBY,QAApCZ,CAAAA,WAAoCY,CAAAA,OAAtB,QAClB,CAAA,OAAO,CAAP,MAAA,CAAe,SAAA,GAAA,OAAiB,mCAAX,CAAW,UAAjB,CAAiB,UAC9B,GAAIC,GAAG,CAAHA,cAAAA,CAAJ,CAAIA,CAAJ,CAA2B,CACzB,KAAM,IAAA,CAAA,KAAA,CAAA,oBAAA,MAAA,CAAA,CAAA,CAAN,iCAAM,CAAA,CAAN,CACD,CAEDA,GAAG,CAAHA,CAAG,CAAHA,CAAAA,CAAAA,CACA,MAAA,CAAA,GAAA,CANF,CAAA,CADF,EACE,CADkB,EAApB,CAUA,GAAMR,CAAAA,YAAY,CAAIb,QAAhBa,CAAAA,YAAgBb,CAAAA,OAAD,QACnBA,CAAAA,OAAO,CAAPA,OAAAA,CAAAA,IAAAA,CAAAA,EAAAA,EAAAA,OAAAA,CAAAA,KAAAA,CADF,EACEA,CADmB,EAArB,CAGA,GAAMsB,CAAAA,SAAS,CAAG,QAAZA,CAAAA,SAAY,2CAAA,KAAA,0CAAA,KAAA,8BAChB,WAAA,MAAA,gCACaC,KAAK,CAALA,GAAAA,CAAWZ,SAAAA,CAAD,QAAOA,CAAAA,CAAC,CAADA,KAAAA,CAD9B,GAC8BA,CAAP,EAAVY,CADb,GAAA,MAAA,CAAA,OAAA,EAAA,IAAA,CADF,GACE,CADgB,EAAlB,CAMA,GAAMC,CAAAA,gBAAgB,CAAG,QAAnBA,CAAAA,gBAAmB,CAAA,MAAA,CAAA,MAAA,CAAA,aAAA,CAIR,CAAA,GAAA,CAAA,SAAA,CACf,GAAI,MAAA,CAAA,MAAA,GAAJ,QAAA,CAAgC,CAE9B,GAAMxB,CAAAA,SAAO,CAAGyB,aAAa,CAAGH,SAAS,CAAA,aAAA,CAAZ,MAAY,CAAZ,CAA7B,MAAA,CAEA,MAAO,CAAEtB,OAAAA,CAAAA,SAAF,CAAP,CALa,CAUf,GAAA,CAAA,OAAA,CAEA,GAAA,MAAA,CAAY,CACVA,OAAO,CACL0B,MAAM,CAANA,KAAAA,GAAAA,IAAAA,EAAAA,aAAAA,EAA0CA,MAAM,CAAhDA,IAAAA,CACIJ,SAAS,CAAA,aAAA,CAAgBI,MAAM,CADnCA,IACa,CADbA,CAEIA,MAAM,CAHZ1B,IAAAA,CADF,CAAA,IAKO,CACL,GAAI0B,MAAM,CAANA,KAAAA,EAAgBA,MAAM,CAANA,IAAAA,GAApB,SAAA,CAA+C,CAC7C,KAAM,IAAA,CAAA,KAAA,CAAN,sJAAM,CAAN,CAGD,CAED1B,OAAO,CACL0B,MAAM,CAANA,KAAAA,GAAAA,IAAAA,CACIJ,SAAS,CAACG,aAAa,EAAd,EAAA,CAAsBC,MAAM,CAANA,IAAAA,EADnCA,EACa,CADbA,CAEIA,MAAM,CAANA,IAAAA,EAHN1B,EAAAA,CAID,CAED,GAAM2B,CAAAA,OAAO,CAAGD,MAAM,CAANA,OAAAA,CACZ/B,uBAAuB,CAAA,MAAA,CAAS+B,MAAM,CAAf,OAAA,CADXA,OACW,CADXA,CAAhB,SAAA,CAIA,MAAO,CAEL1B,OAAO,CAAA,CAAA,SAAA,CAAA,OAAA,IAAA,IAAA,EAAA,SAAA,GAAA,IAAA,EAAA,CAAA,IAAA,EAAA,CAAEA,SAAAA,CAAAA,KAAAA,CAAAA,GAAAA,EAAAA,MAAAA,CAAAA,OAAAA,EAAAA,IAAAA,CAFJ,GAEIA,CAFJ,CAGLM,SAAS,CAAEoB,MAAM,CAHZ,SAAA,CAILC,OAAAA,CAAAA,OAJK,CAAP,CAtCF,CAAA,CA8CA,GAAMhC,CAAAA,uBAAuB,CAAG,QAA1BA,CAAAA,uBAA0B,CAAA,MAAA,CAAA,OAAA,CAAA,OAAA,QAK9Ba,CAAAA,WAAW,CACT,MAAM,CAAN,OAAA,CAAA,OAAA,EAAA,GAAA,CAA4B,eAAe,mCAAd,IAAc,UAAf,CAAe,UACzC,GAAMoB,CAAAA,MAAM,CAAGJ,gBAAgB,CAAA,MAAA,CAAA,CAAA,CAA/B,OAA+B,CAA/B,CAEA,MAAO,CAAA,IAAA,CAAP,MAAO,CAAP,CATN,CAMI,CADS,CALmB,EAAhC","sourcesContent":["import * as queryString from 'query-string';\nimport type {\n  NavigationState,\n  PartialState,\n  Route,\n} from '@react-navigation/routers';\nimport checkLegacyPathConfig from './checkLegacyPathConfig';\nimport type { PathConfig, PathConfigMap } from './types';\n\ntype Options = { initialRouteName?: string; screens: PathConfigMap };\n\ntype State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\ntype StringifyConfig = Record<string, (value: any) => string>;\n\ntype ConfigItem = {\n  pattern?: string;\n  stringify?: StringifyConfig;\n  screens?: Record<string, ConfigItem>;\n};\n\nconst getActiveRoute = (state: State): { name: string; params?: object } => {\n  const route =\n    typeof state.index === 'number'\n      ? state.routes[state.index]\n      : state.routes[state.routes.length - 1];\n\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n\n  return route;\n};\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * @example\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         stringify: { author: author => author.toLowerCase() }\n *       }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport default function getPathFromState(\n  state: State,\n  options?: Options\n): string {\n  if (state == null) {\n    throw Error(\n      \"Got 'undefined' for the navigation state. You must pass a valid state object.\"\n    );\n  }\n\n  const [legacy, compatOptions] = checkLegacyPathConfig(options);\n\n  // Create a normalized configs object which will be easier to use\n  const configs: Record<string, ConfigItem> = compatOptions\n    ? createNormalizedConfigs(legacy, compatOptions.screens)\n    : {};\n\n  let path = '/';\n  let current: State | undefined = state;\n\n  const allParams: Record<string, any> = {};\n\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index] as Route<string> & {\n      state?: State;\n    };\n\n    let pattern: string | undefined;\n\n    let focusedParams: Record<string, any> | undefined;\n    let focusedRoute = getActiveRoute(state);\n    let currentOptions = configs;\n\n    // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\n    let nestedRouteNames = [];\n\n    let hasNext = true;\n\n    while (route.name in currentOptions && hasNext) {\n      pattern = currentOptions[route.name].pattern;\n\n      nestedRouteNames.push(route.name);\n\n      if (route.params) {\n        const stringify = currentOptions[route.name]?.stringify;\n\n        const currentParams = fromEntries(\n          Object.entries(route.params).map(([key, value]) => [\n            key,\n            stringify?.[key] ? stringify[key](value) : String(value),\n          ])\n        );\n\n        if (pattern) {\n          Object.assign(allParams, currentParams);\n        }\n\n        if (focusedRoute === route) {\n          // If this is the focused route, keep the params for later use\n          // We save it here since it's been stringified already\n          focusedParams = { ...currentParams };\n\n          pattern\n            ?.split('/')\n            .filter((p) => p.startsWith(':'))\n            // eslint-disable-next-line no-loop-func\n            .forEach((p) => {\n              const name = getParamName(p);\n\n              // Remove the params present in the pattern since we'll only use the rest for query string\n              if (focusedParams) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete focusedParams[name];\n              }\n            });\n        }\n      }\n\n      // If there is no `screens` property or no nested state, we return pattern\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index =\n          typeof route.state.index === 'number'\n            ? route.state.index\n            : route.state.routes.length - 1;\n\n        const nextRoute = route.state.routes[index];\n        const nestedConfig = currentOptions[route.name].screens;\n\n        // if there is config for next route name, we go deeper\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute as Route<string> & { state?: State };\n          currentOptions = nestedConfig;\n        } else {\n          // If not, there is no sense in going deeper in config\n          hasNext = false;\n        }\n      }\n    }\n\n    if (pattern === undefined) {\n      pattern = nestedRouteNames.join('/');\n    }\n\n    if (currentOptions[route.name] !== undefined) {\n      path += pattern\n        .split('/')\n        .map((p) => {\n          const name = getParamName(p);\n\n          // We don't know what to show for wildcard patterns\n          // Showing the route name seems ok, though whatever we show here will be incorrect\n          // Since the page doesn't actually exist\n          if (p === '*') {\n            if (legacy) {\n              throw new Error(\n                \"Please update your config to the new format to use wildcard pattern ('*'). https://reactnavigation.org/docs/configuring-links/#updating-config\"\n              );\n            }\n\n            return route.name;\n          }\n\n          // If the path has a pattern for a param, put the param in the path\n          if (p.startsWith(':')) {\n            const value = allParams[name];\n\n            if (value === undefined && p.endsWith('?')) {\n              // Optional params without value assigned in route.params should be ignored\n              return '';\n            }\n\n            return encodeURIComponent(value);\n          }\n\n          return encodeURIComponent(p);\n        })\n        .join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n\n    if (!focusedParams) {\n      focusedParams = focusedRoute.params;\n    }\n\n    if (route.state) {\n      path += '/';\n    } else if (focusedParams) {\n      for (let param in focusedParams) {\n        if (focusedParams[param] === 'undefined') {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete focusedParams[param];\n        }\n      }\n\n      const query = queryString.stringify(focusedParams);\n\n      if (query) {\n        path += `?${query}`;\n      }\n    }\n\n    current = route.state;\n  }\n\n  // Remove multiple as well as trailing slashes\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n\n  return path;\n}\n\n// Object.fromEntries is not available in older iOS versions\nconst fromEntries = <K extends string, V>(entries: (readonly [K, V])[]) =>\n  entries.reduce((acc, [k, v]) => {\n    if (acc.hasOwnProperty(k)) {\n      throw new Error(`A value for key '${k}' already exists in the object.`);\n    }\n\n    acc[k] = v;\n    return acc;\n  }, {} as Record<K, V>);\n\nconst getParamName = (pattern: string) =>\n  pattern.replace(/^:/, '').replace(/\\?$/, '');\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nconst createConfigItem = (\n  legacy: boolean,\n  config: PathConfig | string,\n  parentPattern?: string\n): ConfigItem => {\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    return { pattern };\n  }\n\n  // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n  let pattern: string | undefined;\n\n  if (legacy) {\n    pattern =\n      config.exact !== true && parentPattern && config.path\n        ? joinPaths(parentPattern, config.path)\n        : config.path;\n  } else {\n    if (config.exact && config.path === undefined) {\n      throw new Error(\n        \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n      );\n    }\n\n    pattern =\n      config.exact !== true\n        ? joinPaths(parentPattern || '', config.path || '')\n        : config.path || '';\n  }\n\n  const screens = config.screens\n    ? createNormalizedConfigs(legacy, config.screens, pattern)\n    : undefined;\n\n  return {\n    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n    pattern: pattern?.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens,\n  };\n};\n\nconst createNormalizedConfigs = (\n  legacy: boolean,\n  options: PathConfigMap,\n  pattern?: string\n): Record<string, ConfigItem> =>\n  fromEntries(\n    Object.entries(options).map(([name, c]) => {\n      const result = createConfigItem(legacy, c, pattern);\n\n      return [name, result];\n    })\n  );\n"]},"metadata":{},"sourceType":"module"}